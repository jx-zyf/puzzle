{"version":3,"sources":["components/Puzzle/index.js","App.js","serviceWorker.js","index.js"],"names":["toastr","options","closeButton","debug","newestOnTop","progressBar","positionClass","preventDuplicates","onclick","showDuration","hideDuration","timeOut","extendedTimeOut","showEasing","hideEasing","showMethod","hideMethod","Puzzle","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","init","arr","i","push","sort","Math","random","setState","puzzles","time","isStart","undefined","clearInterval","timer","start","state","setInterval","isSuccess","slice","every","item","index","itemClick","curIndex","newPuzzles","emptyIndex","findIndex","rightIndex","leftIndex","includes","console","log","setTimeout","success","concat","warning","_this2","_this$state","react_default","a","createElement","className","map","key","onClick","style","cursor","false","true","Component","App","src_components_Puzzle","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"oQAIAA,IAAOC,QAAU,CACbC,aAAe,EACfC,OAAS,EACTC,aAAe,EACfC,aAAe,EACfC,cAAiB,mBACjBC,mBAAqB,EACrBC,QAAW,KACXC,aAAgB,MAChBC,aAAgB,OAChBC,QAAW,OACXC,gBAAmB,OACnBC,WAAc,QACdC,WAAc,SACdC,WAAc,SACdC,WAAc,eAwHHC,cApHX,SAAAA,IAAc,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAJ,IACVC,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAF,GAAAO,KAAAH,QAaJI,KAAO,WAEH,IADA,IAAIC,EAAM,GACDC,EAAI,EAAGA,EAAI,GAAIA,IACpBD,EAAIE,KAAKD,IAEbD,EAAMA,EAAIG,KAAK,WACX,OAAOC,KAAKC,SAAW,MAEvBH,MAAM,GACVV,EAAKc,SAAS,CACVC,QAASP,EACTQ,KAAM,EACNC,aAASC,IAEbC,cAAcnB,EAAKoB,QA5BTpB,EA+BdqB,MAAQ,WAAM,IACFJ,EAAYjB,EAAKsB,MAAjBL,QACRjB,EAAKc,SAAS,CACVG,SAAUA,IAETA,EAODE,cAAcnB,EAAKoB,OANnBpB,EAAKoB,MAAQG,YAAY,WACrBvB,EAAKc,SAAS,SAACQ,GAAD,MAAY,CACtBN,KAAMM,EAAMN,KAAO,MAExB,MAzCGhB,EA+CdwB,UAAY,WAGR,OAFoBxB,EAAKsB,MAAjBP,QACeU,MAAM,EAAG,IAAIC,MAAM,SAACC,EAAMC,GAAP,OAAiBD,IAASC,EAAQ,KAjDlE5B,EAqDd6B,UAAY,SAACC,GAAa,IACdb,EAAYjB,EAAKsB,MAAjBL,QAEFc,EAAa/B,EAAKsB,MAAMP,QACxBiB,EAAaD,EAAWE,UAAU,SAAAN,GAAI,OAAc,IAAVA,IAE5CO,EAAaJ,EAAW,EAExBK,EAAYL,EAAW,GACX,IAAZb,GAIA,CARWa,EAHH,EAKMA,EALN,GAWgBM,SAASJ,GAEjCD,EAAWC,GAAc,CAACD,EAAWD,GAAWC,EAAWD,GAAYC,EAAWC,IAAa,IACvFF,EAAW,GAdX,IAcwB,GAAKK,IAAcH,EAEnDD,EAAWC,GAAc,CAACD,EAAWD,GAAWC,EAAWD,GAAYC,EAAWC,IAAa,IACvFF,EAAW,GAjBX,IAiBwB,GAAKI,IAAeF,EAEpDD,EAAWC,GAAc,CAACD,EAAWD,GAAWC,EAAWD,GAAYC,EAAWC,IAAa,GAE/FK,QAAQC,IAAI,kCAEhBtC,EAAKc,SAAS,CACVC,QAASgB,IAEbQ,WAAW,WACHvC,EAAKwB,cACL1C,IAAO0D,QAAP,4EAAAC,OAA+BzC,EAAKsB,MAAMN,KAA1C,YACAG,cAAcnB,EAAKoB,SAExB,MAvBCtC,IAAO4D,QAAQ,mFA7DnB1C,EAAKsB,MAAQ,CACTP,QAAS,GACTC,KAAM,EACNC,aAASC,GAEblB,EAAKoB,MAAQ,KAPHpB,mFAWVG,KAAKI,wCA8EA,IAAAoC,EAAAxC,KAAAyC,EAC8BzC,KAAKmB,MAAhCP,EADH6B,EACG7B,QAASC,EADZ4B,EACY5B,KAAMC,EADlB2B,EACkB3B,QAMvB,OACI4B,EAAAC,EAAAC,cAAA,WACIF,EAAAC,EAAAC,cAAA,KAAGC,UAAU,QAAb,gBAAuBH,EAAAC,EAAAC,cAAA,YAAO/B,GAA9B,UACA6B,EAAAC,EAAAC,cAAA,MAAIC,UAAU,cACTjC,EAAQkC,IAAI,SAACtB,EAAMC,GAAP,OACTiB,EAAAC,EAAAC,cAAA,MACIC,WAAqB,IAAVrB,EAAc,oBAAsB,cAC/CuB,IAAKvB,EACLwB,QAAS,kBAAMR,EAAKd,UAAUD,IAC9BwB,OAAmB,IAAZnC,EAAmB,CAACoC,OAAQ,eAAkB,IACvD1B,MAGVkB,EAAAC,EAAAC,cAAA,UAAQC,UAAU,YAAYG,QAAShD,KAAKkB,OAlBlC,CACdH,UAAW,eACXoC,MAAO,eACPC,KAAM,gBAe4DtC,IAC9D4B,EAAAC,EAAAC,cAAA,UAAQC,UAAU,YAAYG,QAAShD,KAAKI,MAA5C,wBA/GKiD,aCPNC,0LARX,OACEZ,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACbH,EAAAC,EAAAC,cAACW,EAAD,cAJUF,cCOEG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAOpB,EAAAC,EAAAC,cAACmB,EAAD,MAASC,SAASC,eAAe,SDuH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.58bbd953.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport toastr from 'toastr';\r\nimport './index.css';\r\n\r\ntoastr.options = {\r\n    \"closeButton\": false,\r\n    \"debug\": false,\r\n    \"newestOnTop\": false,\r\n    \"progressBar\": false,\r\n    \"positionClass\": \"toast-top-center\",\r\n    \"preventDuplicates\": false,\r\n    \"onclick\": null,\r\n    \"showDuration\": \"300\",\r\n    \"hideDuration\": \"1000\",\r\n    \"timeOut\": \"2500\",\r\n    \"extendedTimeOut\": \"1000\",\r\n    \"showEasing\": \"swing\",\r\n    \"hideEasing\": \"linear\",\r\n    \"showMethod\": \"fadeIn\",\r\n    \"hideMethod\": \"fadeOut\"\r\n}\r\n\r\nclass Puzzle extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            puzzles: [],\r\n            time: 0,\r\n            isStart: undefined,\r\n        };\r\n        this.timer = null;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.init();\r\n    }\r\n\r\n    init = () => {\r\n        let arr = [];\r\n        for (let i = 1; i < 16; i++ ) {\r\n            arr.push(i);\r\n        }\r\n        arr = arr.sort(() => {\r\n            return Math.random() - 0.5;\r\n        });\r\n        arr.push(-1);\r\n        this.setState({ \r\n            puzzles: arr,\r\n            time: 0,\r\n            isStart: undefined,\r\n        });\r\n        clearInterval(this.timer);\r\n    }\r\n\r\n    start = () => {\r\n        const { isStart } = this.state;\r\n        this.setState({\r\n            isStart: !isStart,\r\n        })\r\n        if (!isStart) {\r\n            this.timer = setInterval(() => {\r\n                this.setState((state) => ({\r\n                    time: state.time + 1\r\n                }));\r\n            }, 1000);\r\n        } else {\r\n            clearInterval(this.timer);\r\n        }\r\n    }\r\n\r\n    isSuccess = () => {\r\n        const { puzzles } = this.state;\r\n        const result = puzzles.slice(0, 15).every((item, index) => item === index + 1);\r\n        return result;\r\n    }\r\n\r\n    itemClick = (curIndex) => {\r\n        const { isStart } = this.state;\r\n        const NUM = 4;\r\n        const newPuzzles = this.state.puzzles;\r\n        const emptyIndex = newPuzzles.findIndex(item => item === -1);\r\n        let topIndex = curIndex - NUM,\r\n            rightIndex = curIndex + 1,\r\n            bottomIndex = curIndex + NUM,\r\n            leftIndex = curIndex - 1;\r\n        if (isStart !== true) {\r\n            toastr.warning('游戏尚未开始或游戏暂停中！');\r\n            return;\r\n        }\r\n        if ([topIndex, bottomIndex].includes(emptyIndex)) {\r\n            // 上、下\r\n            newPuzzles[emptyIndex] = [newPuzzles[curIndex], newPuzzles[curIndex] = newPuzzles[emptyIndex]][0];\r\n        } else if ((curIndex + 1) % NUM !== 1 && leftIndex === emptyIndex) {\r\n            // 左 当前点击的方块不能是最左边的\r\n            newPuzzles[emptyIndex] = [newPuzzles[curIndex], newPuzzles[curIndex] = newPuzzles[emptyIndex]][0];\r\n        } else if ((curIndex + 1) % NUM !== 0 && rightIndex === emptyIndex) {\r\n            // 右 当前点击的方块不能是最右边的\r\n            newPuzzles[emptyIndex] = [newPuzzles[curIndex], newPuzzles[curIndex] = newPuzzles[emptyIndex]][0];\r\n        } else {\r\n            console.log('啥也不做！');\r\n        }\r\n        this.setState({\r\n            puzzles: newPuzzles\r\n        })\r\n        setTimeout(() => {\r\n            if (this.isSuccess()) {\r\n                toastr.success(`恭喜你！成功了！总共耗时 ${this.state.time} 秒`);\r\n                clearInterval(this.timer);\r\n            }\r\n        }, 100)\r\n    }\r\n\r\n    render() {\r\n        const { puzzles, time, isStart } = this.state;\r\n        const txtConfig = {\r\n            undefined: '开始',\r\n            false: '继续',\r\n            true: '暂停',\r\n        }\r\n        return (\r\n            <div>\r\n                <p className='time'>时间:<span>{time}</span>秒</p>\r\n                <ul className='puzzle_box'>\r\n                    {puzzles.map((item, index) => (\r\n                        <li \r\n                            className={item === -1 ? 'puzzle_item empty' : 'puzzle_item'} \r\n                            key={item} \r\n                            onClick={() => this.itemClick(index)}\r\n                            style={isStart !== true ? {cursor: 'not-allowed' } : {}}\r\n                        >{item}</li>\r\n                    ))}\r\n                </ul>\r\n                <button className='start_btn' onClick={this.start}>{txtConfig[isStart]}</button>\r\n                <button className='reset_btn' onClick={this.init}>重置</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Puzzle;","import React, { Component } from 'react';\nimport Puzzle from './components/Puzzle';\n\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Puzzle />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}